/*
 * Copyright (C) 2024 Hiero a Series of LF Projects, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

plugins {
    id("java")
    id("org.gradlex.reproducible-builds")
}

@Suppress("UnstableApiUsage")
val fullJavaVersion =
    providers
        .fileContents(isolated.rootProject.projectDirectory.file("gradle/jdk-version.txt"))
        .asText
        .orElse(provider { throw RuntimeException("gradle/jdk-version.txt file not found") })
        .get()
        .trim()
val majorJavaVersion = JavaVersion.toVersion(fullJavaVersion)
val currentJavaVersion = providers.systemProperty("java.version").get()

if (currentJavaVersion != fullJavaVersion) {
    val message =
        "Gradle runs with Java $currentJavaVersion. This project works best running with Java $fullJavaVersion. " +
            "\n - From commandline: change JAVA_HOME and/or PATH to point at Java $fullJavaVersion installation." +
            "\n - From IntelliJ: change 'Gradle JVM' in 'Gradle Settings' to point at Java $fullJavaVersion installation."

    logger.lifecycle("WARN: $message")
}

java {
    sourceCompatibility = majorJavaVersion
    targetCompatibility = majorJavaVersion
}

tasks.withType<JavaCompile>().configureEach {
    // Track the full Java version as input (e.g. 17.0.3 vs. 17.0.9).
    // By default, Gradle only tracks the major version as defined in the toolchain (e.g. 17).
    // Since the full version is encoded in 'module-info.class' files, it should be tracked as
    // it otherwise leads to wrong build cache hits.
    inputs.property("fullJavaVersion", currentJavaVersion)

    options.javaModuleVersion = provider { project.version as String }

    options.isFork = true // run compiler in separate JVM process (independent of toolchain setup)

    doLast {
        // Make sure consistent line ending are used in files generated by annotation processors by
        // rewriting generated files.
        // To fix this problem at the root, one of these issues needs to be addressed upstream:
        // - https://github.com/google/auto/issues/1656
        // - https://github.com/gradle/gradle/issues/27385
        if (System.lineSeparator() != "\n") {
            destinationDirectory
                .get()
                .asFileTree
                .filter { it.extension != "class" }
                .forEach {
                    val content = it.readText()
                    val normalizedContent = content.replace(System.lineSeparator(), "\n")
                    if (content != normalizedContent) {
                        it.writeText(normalizedContent)
                    }
                }
        }
    }
}

tasks.jar { manifest { attributes["Implementation-Version"] = project.version } }

sourceSets.all {
    // 'assemble' compiles all sources, including all test sources
    tasks.assemble { dependsOn(tasks.named(classesTaskName)) }
}
